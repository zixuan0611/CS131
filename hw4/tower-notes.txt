A Note for Homework4. Towers solver

% This is an assignment for prolog.
In our source code, we cite:
https://stackoverflow.com/questions/4280986/how-to-transpose-a-matrix-in-prolog
to make a transpose of our matrix to help write our predicates.

The performance difference on the test case:
(The argument C can be generated by the website provided in the syllabus:
https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/towers.html)
tower(5, T, counts([2,2,1,2,5],
                [2,3,4,3,1],
                [3,4,2,1,2],
                [3,2,3,2,1]))
plain_tower(5, T, counts(([2,2,1,2,5],
                [2,3,4,3,1],
                [3,4,2,1,2],
                [3,2,3,2,1]))

We choose N to be 5, meaning the square grid is 5*5 because my plain_tower
is too fast when the square grid is smller than 5*5. (e.g. 4*4). So we use 5
here to aviod zero division.
Then we use speedup to package up the test case running both tower and 
plain_tower as well as measuring performance with statistics. The
speedup unifies the argument to a floating-point ratio of the plain_tower's
CPU time to the tower's CPU time.

After running with the speedup, we find that at our test case (N = 5), the
ratio would be mostly and approximately 92.0.
meaning that tower is much faster than plain_tower. This is because 
plain_tower enumerates possible integer solutions using member and is. 
While this is simpler and not restricted to integers less than vector_max, 
it takes much more time and thus the performance measured by statistics is 
worse than tower.

The example ambiguous puzzle we find using (4, C, T1, T2) is:
C = counts([1,2,2,3],[3,2,2,1],[1,2,2,3],[3,2,2,1])
T1 = [[4,3,1,2],[3,2,4,1],[1,4,2,3],[2,1,3,4]]
T2 = [[4,2,3,1],[2,1,4,3],[3,4,1,2],[1,3,2,4]]
